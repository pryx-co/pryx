Product Requirements Document (PRD): Pryx1. Executive SummaryPryx is a second-generation "Sovereign AI Agent" designed to replace fragile, script-based local assistants (like Clawdbot) with a robust, compiled, and user-friendly application. By leveraging a polyglot architecture—TypeScript (UI), Rust (Shell), and Go (Brain)—Pryx eliminates the "User Experience (UX) Debt" of current tools. It creates a seamless "Localhost" experience where the user owns the data, but the cloud (Cloudflare Workers) handles the complexity of authentication and observability.2. Problem StatementCurrent market leaders in local AI agents, such as Clawdbot, suffer from significant usability and security flaws:High Friction Setup: Users must manage their own Node.js runtimes, leading to version conflicts and "dependency hell".Headless Operation: The lack of a native GUI forces users to edit JSON config files (~/.clawdbot/clawdbot.json) and manage connections via command line, creating a "Blind State" regarding agent health.Security Gaps: Monolithic architectures often run with full user privileges without adequate "Human-in-the-Loop" authorization gates .3. Goals & ObjectivesZero-Config Distribution: Deliver a single installable binary (.dmg, .exe) that requires no external runtime dependencies (Node/Python).The "Sidecar" Pattern: Decouple the UI (Rust/TS) from the Agent (Go) to ensure crash resilience and high-performance concurrency .Sovereign Observability: Provide enterprise-grade telemetry (OTLP) via a private edge network, giving users visibility into agent actions without sacrificing privacy.Frictionless Auth: Implement OAuth 2.0 Device Flow to securely authenticate with third-party services (GitHub, Google) without manual API key pasting .4. Technical Architecture: The "Pryx Stack"4.1 Component DiagramThe system follows the Sidecar Pattern popularized by tools like OpenCode.The Host (Rust + Tauri v2):Role: Application lifecycle, native window management, system tray, and sidecar supervision.Implementation: Uses tauri::shell::sidecar to spawn the Go binary. It acts as the "Supervisor," intercepting dangerous requests from the agent before they reach the OS.The Sidecar (Go):Role: The "Brain." Handles LLM inference (Anthropic/OpenAI), tool execution (File I/O, Shell), and third-party webhooks.Implementation: A standalone Go binary compiled with net/http and gorilla/websocket. It runs an HTTP server on a random local port, which the Host discovers upon spawning .The Interface (TypeScript + React):Role: The "Control Center." A rich GUI for chat, configuration, and telemetry visualization.Implementation: Bundled within the Tauri webview. Communicates with the Go Sidecar via localhost HTTP/WebSocket.The Control Plane (Cloudflare Workers):Role: Stateless authentication and telemetry ingestion.Implementation:auth-worker: Handles OAuth 2.0 Device Flow (RFC 8628).telemetry-worker: Ingests OTLP traces and sanitizes PII before forwarding to storage .5. Functional RequirementsFR1: Agent Runtime (The Go Sidecar)FR1.1 - Headless Capable: The Go binary must be capable of running independently of the UI for "server" deployments (e.g., on a headless Raspberry Pi), similar to OpenCode's server mode .FR1.2 - Tool Protocol (MCP): The agent must implement the Model Context Protocol (MCP) to dynamically discover and execute tools, allowing for future extensibility without recompilation.FR1.3 - Concurrency: The agent must utilize Go routines to handle at least 50 concurrent webhooks (e.g., WhatsApp, Telegram) without blocking the main LLM inference loop.FR2: Native Shell (The Rust Host)FR2.1 - Process Management: The Rust process must manage the pryx-core (Go) binary, ensuring it starts when the app opens and terminates gracefully when the app closes (SIGTERM).FR2.2 - Deep Linking: The application must register a custom protocol (pryx://) to allow deep-linking from the web browser to specific agent sessions.FR2.3 - Permission Gating: Critical tools (e.g., fs.delete, shell.execute) must require explicit user approval via a native system dialog triggered by the Rust Host .FR3: User Interface (The Localhost UI)FR3.1 - Visual Configuration: Users must be able to configure integrations (e.g., "Connect Telegram") via a GUI that displays QR codes or Auth codes, replacing the legacy config.json editing.FR3.2 - Live Telemetry: The UI must include an "Observability" tab that renders a live Gantt chart of the agent's internal "thought process" (traces), streamed directly from the Go Sidecar.FR4: Authentication & Cloud (Cloudflare Workers)FR4.1 - Device Flow Auth: The system must support the OAuth 2.0 Device Grant.User Story: "As a user, I want to log in by scanning a QR code or visiting a URL on my phone, so I don't have to copy-paste sensitive API keys." .FR4.2 - Stateless Operation: The Cloudflare Workers must not persist user data or conversation history. They act strictly as a pass-through layer for Auth handshakes and Telemetry ingestion.6. Security RequirementsSR1 - Local Data Sovereignty: All conversation history (sqlite), vector indices, and file storage must remain on the user's local disk. No data is synced to the cloud unless explicitly configured for backup.SR2 - Secret Management: API Keys (e.g., Anthropic Key) must be stored in the OS-native Keychain (Windows Credential Manager, macOS Keychain) via the Rust/Go keyring libraries, never in plain text files.SR3 - Blast Radius Containment: The Go Sidecar should operate with the principle of least privilege. Any shell command execution must be scoped to the specific Workspace directory unless overridden .7. Implementation RoadmapPhase 1: The Core (Go)Develop pryx-core binary in Go.Implement basic Loopback HTTP server and WebSocket event stream.Implement MCP client for local tool execution.Phase 2: The Shell (Rust/Tauri)Set up Tauri v2 project structure.Configure externalBin to bundle pryx-core.Implement sidecar spawning and port discovery logic (parsing stdout).Phase 3: The Control Plane (Cloudflare)Deploy auth-worker implementing RFC 8628 (Device Code).Deploy telemetry-worker for OTLP ingestion.Phase 4: The UI (React)Build the "Connection Manager" dashboard.Implement the chat interface with Markdown/Code highlighting.Integrate the "Permission Request" modal system.8. Success MetricsTime-to-Hello-World: < 2 minutes (Download -> Install -> First Chat).Stability: Zero "zombie processes" left after application close.Developer Velocity: Ability to add a new tool (e.g., "Google Calendar") and deploy it to the agent without rebuilding the Rust Shell.